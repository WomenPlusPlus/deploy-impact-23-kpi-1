-- DROP existing tables and views
DROP VIEW if exists kpi_values;
DROP TABLE if exists kpi_values_history;
DROP TABLE if exists kpi_values;
DROP TABLE if exists target;
DROP TABLE if exists circle_kpi_definition;
DROP TABLE if exists kpi_definition;
DROP TABLE if exists circle_user;
DROP TABLE if exists kpi_user;
DROP TABLE if exists circle;

-- DROP all existing types
DROP TYPE IF EXISTS role;
DROP TYPE IF EXISTS action;
DROP TYPE IF EXISTS periodicity;
DROP TYPE IF EXISTS unit;

-- Define types
CREATE type periodicity as enum ('daily', 'weekly', 'monthly', 'quarterly', 'yearly');
CREATE type unit as enum ('%', 'boolean', 'numeric');
CREATE type role as enum ('admin', 'user');
CREATE type action as enum ('CREATE', 'UPDATE', 'DELETE');

-- Enable MODDATETIME extension
CREATE extension if not exists moddatetime schema extensions;

CREATE TABLE public.kpi_definition (
    kpi_id int8 generated by default as identity,
    kpi_name varchar(255) not null unique,
    description varchar(255),
    periodicity periodicity not null,
    value_min int8,
    value_max int8,
    unit unit not null,
    created_at timestamp default current_timestamp not null,
    updated_at timestamp,
    PRIMARY KEY (kpi_id)
);

-- This will set the `updated_at` column on every update
CREATE TRIGGER kpi_def_updated_at before update on public.kpi_definition
  for each row execute procedure moddatetime (updated_at);

CREATE TABLE public.circle (
    circle_id int8 generated by default as identity,
    circle_name varchar(255) not null unique,
    created_at timestamp default current_timestamp not null,
    updated_at timestamp,
    PRIMARY KEY (circle_id)
);

-- This will set the `updated_at` column on every update
CREATE TRIGGER circle_updated_at before update on public.circle
  for each row execute procedure moddatetime (updated_at);

CREATE TABLE public.kpi_user (
    user_id uuid not null default auth.uid (),
    user_name character varying(255) not null unique,
    role public.role not null,
    created_at timestamp default current_timestamp not null,
    updated_at timestamp,
    PRIMARY KEY (user_id),
    CONSTRAINT kpi_user_user_id_key unique (user_id),
    CONSTRAINT fk_auth_user 
        FOREIGN KEY (user_id)
        REFERENCES auth.users (id)
  );

-- This will set the `updated_at` column on every update
CREATE TRIGGER user_updated_at before update on public.kpi_user
  for each row execute procedure moddatetime (updated_at);  

CREATE TABLE public.circle_user (
    circle_user_id int8 generated by default as identity,
    circle_id int8 not null,
    user_id uuid not null default auth.uid (),
    PRIMARY KEY (circle_user_id),
    CONSTRAINT fk_circle_id 
        FOREIGN KEY (circle_id)
        REFERENCES circle(circle_id),
    CONSTRAINT fk_auth_user 
        FOREIGN KEY (user_id)
        REFERENCES auth.users (id),
    CONSTRAINT u_constraint_circle_user unique (circle_id, user_id)
);

CREATE TABLE public.circle_kpi_definition (
    circle_kpidef_id int8 generated by default as identity,
    circle_id int8 not null,
    kpi_id int8 not null,
    PRIMARY KEY (circle_kpidef_id),
    CONSTRAINT fk_circle_id 
        FOREIGN KEY (circle_id) 
        REFERENCES circle(circle_id),
    CONSTRAINT fk_kpi_def 
        FOREIGN KEY (kpi_id)
        REFERENCES kpi_definition(kpi_id),
    CONSTRAINT u_constrant_circle_kpi unique (circle_id, kpi_id)
);

CREATE TABLE public.target (
    target_id int8 generated by default as identity,
    kpi_id int8 not null,
    target_value numeric not null,
    unit unit not null,
    timeframe date not null,
    created_at timestamp default current_timestamp not null,
    updated_at timestamp,
    PRIMARY KEY (target_id),
    CONSTRAINT fk_kpi
        FOREIGN KEY(kpi_id) 
        REFERENCES kpi_definition(kpi_id)
);

-- This will set the `updated_at` column on every update
CREATE TRIGGER target_updated_at before update on public.target
  for each row execute procedure moddatetime (updated_at);

CREATE TABLE public.kpi_values_history (
    kpi_value_history_id int8 generated by default as identity,
    kpi_id int8 not null,
    circle_id int8 not null,
    user_id uuid not null default auth.uid (),
    value numeric not null,
    period_date date not null,
    action action not null,
    created_at timestamp default current_timestamp not null,
    PRIMARY KEY(kpi_value_history_id),
    CONSTRAINT fk_kpi
        FOREIGN KEY(kpi_id) 
        REFERENCES kpi_definition(kpi_id),
    CONSTRAINT fk_circle
        FOREIGN KEY(circle_id) 
        REFERENCES circle(circle_id),
    CONSTRAINT fk_auth_user
        FOREIGN KEY (user_id)
        REFERENCES auth.users (id)
);

CREATE VIEW
  public.kpi_values AS
SELECT
  t1.kpi_value_history_id,
  t1.kpi_id,
  t1.circle_id,
  t1.user_id,
  t1.value,
  t1.period_date,
  t1.action,
  t1.created_at
FROM
  kpi_values_history t1
  JOIN (
    SELECT
      kpi_values_history.kpi_id,
      kpi_values_history.circle_id,
      kpi_values_history.period_date,
      max(kpi_values_history.created_at) AS updated_at
    FROM
      kpi_values_history
    GROUP BY
      kpi_values_history.kpi_id,
      kpi_values_history.circle_id,
      kpi_values_history.period_date
  ) t2 ON t1.kpi_id = t2.kpi_id
  AND t1.circle_id = t2.circle_id
  AND t1.period_date = t2.period_date
  AND t1.created_at = t2.updated_at;


create view
  public.kpi_values_period_standardized as
select distinct
  on (
    kd.kpi_id,
    (
      case
        when kd.periodicity = 'yearly'::periodicity then date_trunc(
          'year'::text,
          t1.period_date::timestamp with time zone
        ) + '1 year'::interval - '1 day'::interval
        when kd.periodicity = 'monthly'::periodicity then date_trunc(
          'month'::text,
          t1.period_date::timestamp with time zone
        ) + '1 mon'::interval - '1 day'::interval
        when kd.periodicity = 'quarterly'::periodicity then date_trunc(
          'quarter'::text,
          t1.period_date::timestamp with time zone
        ) + '3 mons'::interval - '1 day'::interval
        when kd.periodicity = 'weekly'::periodicity then date_trunc(
          'week'::text,
          t1.period_date::timestamp with time zone
        ) + '7 days'::interval - '1 day'::interval
        else t1.period_date::timestamp with time zone
      end
    ),
    t1.circle_id
  ) t1.kpi_value_history_id,
  t1.kpi_id,
  t1.circle_id,
  t1.user_id,
  t1.value,
  t1.period_date,
  t1.action,
  t1.created_at,
  kd.periodicity as kpi_periodicity,
  case
    when kd.periodicity = 'yearly'::periodicity then date_trunc(
      'year'::text,
      t1.period_date::timestamp with time zone
    ) + '1 year'::interval - '1 day'::interval
    when kd.periodicity = 'monthly'::periodicity then date_trunc(
      'month'::text,
      t1.period_date::timestamp with time zone
    ) + '1 mon'::interval - '1 day'::interval
    when kd.periodicity = 'quarterly'::periodicity then date_trunc(
      'quarter'::text,
      t1.period_date::timestamp with time zone
    ) + '3 mons'::interval - '1 day'::interval
    when kd.periodicity = 'weekly'::periodicity then date_trunc(
      'week'::text,
      t1.period_date::timestamp with time zone
    ) + '7 days'::interval - '1 day'::interval
    else t1.period_date::timestamp with time zone
  end as standardized_date
from
  kpi_values_history t1
  join kpi_definition kd on t1.kpi_id = kd.kpi_id
order by
  kd.kpi_id,
  (
    case
      when kd.periodicity = 'yearly'::periodicity then date_trunc(
        'year'::text,
        t1.period_date::timestamp with time zone
      ) + '1 year'::interval - '1 day'::interval
      when kd.periodicity = 'monthly'::periodicity then date_trunc(
        'month'::text,
        t1.period_date::timestamp with time zone
      ) + '1 mon'::interval - '1 day'::interval
      when kd.periodicity = 'quarterly'::periodicity then date_trunc(
        'quarter'::text,
        t1.period_date::timestamp with time zone
      ) + '3 mons'::interval - '1 day'::interval
      when kd.periodicity = 'weekly'::periodicity then date_trunc(
        'week'::text,
        t1.period_date::timestamp with time zone
      ) + '7 days'::interval - '1 day'::interval
      else t1.period_date::timestamp with time zone
    end
  ) desc,
  t1.circle_id,
  t1.created_at desc;


  create view
  public.kpi_definition_with_latest_values as
select
  ckd.circle_kpidef_id,
  ckd.circle_id,
  kd.kpi_id,
  kd.kpi_name,
  kd.description,
  kd.periodicity,
  kd.value_min,
  kd.value_max,
  kd.unit,
  kd.created_at as kpi_created_at,
  kd.updated_at as kpi_updated_at,
  t1.latest_value,
  t1.latest_user_id,
  t1.latest_standardized_date
from
  circle_kpi_definition ckd
  join kpi_definition kd on ckd.kpi_id = kd.kpi_id
  left join (
    select
      kv.kpi_id,
      kv.circle_id,
      kv.standardized_date as latest_standardized_date,
      kv.value as latest_value,
      kv.user_id as latest_user_id
    from
      kpi_values_period_standardized kv
      join (
        select
          kpi_values_period_standardized.kpi_id,
          kpi_values_period_standardized.circle_id,
          max(kpi_values_period_standardized.standardized_date) as max_standardized_date
        from
          kpi_values_period_standardized
        group by
          kpi_values_period_standardized.kpi_id,
          kpi_values_period_standardized.circle_id
      ) max_dates on kv.kpi_id = max_dates.kpi_id
      and kv.circle_id = max_dates.circle_id
      and kv.standardized_date = max_dates.max_standardized_date
  ) t1 on ckd.kpi_id = t1.kpi_id
  and ckd.circle_id = t1.circle_id;
