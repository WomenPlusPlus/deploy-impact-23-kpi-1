-- DROP existing tables and views
DROP VIEW if exists kpi_values;
DROP TABLE if exists kpi_values_history;
DROP TABLE if exists kpi_values;
DROP TABLE if exists target;
DROP TABLE if exists circle_kpi_definition;
DROP TABLE if exists kpi_definition;
DROP TABLE if exists circle_user;
DROP TABLE if exists kpi_user;
DROP TABLE if exists circle;

-- DROP all existing types
DROP TYPE IF EXISTS role;
DROP TYPE IF EXISTS action;
DROP TYPE IF EXISTS periodicity;
DROP TYPE IF EXISTS unit;

-- Define types
CREATE type periodicity as enum ('daily', 'weekly', 'monthly', 'quarterly', 'yearly');
CREATE type unit as enum ('%', 'boolean', 'numeric');
CREATE type role as enum ('admin', 'user');
CREATE type action as enum ('CREATE', 'UPDATE', 'DELETE');

-- Enable MODDATETIME extension
CREATE extension if not exists moddatetime schema extensions;

CREATE TABLE public.kpi_definition (
    kpi_id int8 generated by default as identity,
    kpi_name varchar(255) not null unique,
    description varchar(255),
    periodicity periodicity not null,
    value_min int8,
    value_max int8,
    unit unit,
    created_at timestamp default current_timestamp,
    updated_at timestamp,
    PRIMARY KEY (kpi_id)
);

-- This will set the `updated_at` column on every update
CREATE TRIGGER kpi_def_updated_at before update on public.kpi_definition
  for each row execute procedure moddatetime (updated_at);

CREATE TABLE public.circle (
    circle_id int8 generated by default as identity,
    circle_name varchar(255) not null unique,
    created_at timestamp default current_timestamp,
    updated_at timestamp,
    PRIMARY KEY (circle_id)
);

-- This will set the `updated_at` column on every update
CREATE TRIGGER circle_updated_at before update on public.circle
  for each row execute procedure moddatetime (updated_at);

CREATE TABLE public.kpi_user (
    user_id uuid not null default auth.uid (),
    user_name character varying(255) not null unique,
    role public.role not null,
    created_at timestamp default current_timestamp,
    updated_at timestamp,
    PRIMARY KEY (user_id),
    CONSTRAINT kpi_user_user_id_key unique (user_id),
    CONSTRAINT fk_auth_user 
        FOREIGN KEY (user_id)
        REFERENCES auth.users (id)
  );

-- This will set the `updated_at` column on every update
CREATE TRIGGER user_updated_at before update on public.kpi_user
  for each row execute procedure moddatetime (updated_at);  

CREATE TABLE public.circle_user (
    circle_user_id int8 generated by default as identity,
    circle_id int8 not null,
    user_id uuid not null default auth.uid (),
    PRIMARY KEY (circle_user_id),
    CONSTRAINT fk_circle_id 
        FOREIGN KEY (circle_id)
        REFERENCES circle(circle_id),
    CONSTRAINT fk_auth_user 
        FOREIGN KEY (user_id)
        REFERENCES auth.users (id),
    CONSTRAINT u_constraint_circle_user unique (circle_id, user_id)
);

CREATE TABLE public.circle_kpi_definition (
    circle_kpidef_id int8 generated by default as identity,
    circle_id int8 not null,
    kpi_id int8 not null,
    PRIMARY KEY (circle_kpidef_id),
    CONSTRAINT fk_circle_id 
        FOREIGN KEY (circle_id) 
        REFERENCES circle(circle_id),
    CONSTRAINT fk_kpi_def 
        FOREIGN KEY (kpi_id)
        REFERENCES kpi_definition(kpi_id),
    CONSTRAINT u_constrant_circle_kpi unique (circle_id, kpi_id)
);

CREATE TABLE public.target (
    target_id int8 generated by default as identity,
    kpi_id int8 not null,
    target_value numeric not null,
    unit unit not null,
    timeframe date not null,
    created_at timestamp default current_timestamp,
    updated_at timestamp,
    PRIMARY KEY (target_id),
    CONSTRAINT fk_kpi
        FOREIGN KEY(kpi_id) 
        REFERENCES kpi_definition(kpi_id)
);

-- This will set the `updated_at` column on every update
CREATE TRIGGER target_updated_at before update on public.target
  for each row execute procedure moddatetime (updated_at);

CREATE TABLE public.kpi_values_history (
    kpi_value_history_id int8 generated by default as identity,
    kpi_id int8 not null,
    circle_id int8 not null,
    user_id uuid not null default auth.uid (),
    value numeric not null,
    period_year int8 not null,
    period_month int8 not null,
    action action not null,
    created_at timestamp default current_timestamp,
    PRIMARY KEY(kpi_value_history_id),
    CONSTRAINT fk_kpi
        FOREIGN KEY(kpi_id) 
        REFERENCES kpi_definition(kpi_id),
    CONSTRAINT fk_circle
        FOREIGN KEY(circle_id) 
        REFERENCES circle(circle_id),
    CONSTRAINT fk_auth_user
        FOREIGN KEY (user_id)
        REFERENCES auth.users (id)
);

CREATE VIEW
  public.kpi_values AS
SELECT
  t1.kpi_value_history_id,
  t1.kpi_id,
  t1.circle_id,
  t1.user_id,
  t1.value,
  t1.period_year,
  t1.period_month,
  t1.action,
  t1.created_at
FROM
  kpi_values_history t1
  JOIN (
    SELECT
      kpi_values_history.kpi_id,
      kpi_values_history.circle_id,
      kpi_values_history.period_year,
      kpi_values_history.period_month,
      max(kpi_values_history.created_at) AS updated_at
    FROM
      kpi_values_history
    GROUP BY
      kpi_values_history.kpi_id,
      kpi_values_history.circle_id,
      kpi_values_history.period_year,
      kpi_values_history.period_month
  ) t2 ON t1.kpi_id = t2.kpi_id
  AND t1.circle_id = t2.circle_id
  AND t1.period_year = t2.period_year
  AND t1.period_month = t2.period_month
  AND t1.created_at = t2.updated_at;


-- INSERT some dummy data
INSERT INTO public.circle (circle_name)
VALUES 
    ('HR'),
    ('Fundraising'),
    ('Digital'),
    ('Programs');

INSERT INTO public.kpi_definition (kpi_name, periodicity, description, value_min, value_max, unit)
VALUES 
  ('private donations', 'monthly', 'count of how many private donations in a month', 0, null, 'numeric'),
  ('share short term leave', 'monthly', null,  0, 100, '%'),
  ('additional monetization/savings from CRM', 'quarterly', null, 0, null, 'numeric');
